<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Library Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        .output {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 3px;
            font-family: monospace;
            white-space: pre-wrap;
            margin: 10px 0;
        }
        .error {
            color: #dc3545;
        }
        .success {
            color: #28a745;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Neural Network Library Test</h1>

        <div class="test-section">
            <h3>1. Graphics Context Initialization</h3>
            <button onclick="initTest()">Initialize Graphics Context</button>
            <div id="init-output" class="output"></div>
        </div>

        <div class="test-section">
            <h3>2. Create Network</h3>
            <p>Creates a 2-input → 4-hidden → 1-output network</p>
            <button onclick="createNetworkTest()">Create Network</button>
            <div id="network-output" class="output"></div>
        </div>

        <div class="test-section">
            <h3>3. Forward Propagation Test</h3>
            <p>Test forward pass with sample inputs</p>
            <button onclick="forwardTest()">Run Forward Pass</button>
            <div id="forward-output" class="output"></div>
        </div>

        <div class="test-section">
            <h3>4. XOR Training Test</h3>
            <p>Train network to learn XOR function</p>
            <button onclick="trainingTest()">Train Network</button>
            <div id="training-output" class="output"></div>
        </div>

        <div class="test-section">
            <h3>5. Performance Test</h3>
            <p>Measure forward pass performance</p>
            <button onclick="performanceTest()">Run Performance Test</button>
            <div id="performance-output" class="output"></div>
        </div>

        <div class="test-section">
            <h3>6. Debug: Check Gradients</h3>
            <p>Verify backpropagation is computing gradients</p>
            <button onclick="debugGradients()">Check Gradients</button>
            <div id="debug-output" class="output"></div>
        </div>
    </div>

    <script src="../dist/neural-network.js"></script>
    <script>
        const {
            initializeGraphicsContext,
            initializeNetwork,
            createLayerSpecification,
            computeNetworkForward,
            trainNetworkSingleStep
        } = NeuralNetwork;

        let context = null;
        let network = null;

        function log(elementId, message, type = '') {
            const element = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            const className = type ? ` class="${type}"` : '';
            element.innerHTML += `<div${className}>[${timestamp}] ${message}</div>`;
        }

        window.initTest = function() {
            const output = document.getElementById('init-output');
            output.innerHTML = '';

            try {
                context = initializeGraphicsContext();
                log('init-output', 'Graphics context initialized successfully!', 'success');
                log('init-output', `WebGL2 support: ${context.gl ? 'Yes' : 'No'}`);
                log('init-output', `Float texture support: ${context.gl.getExtension('EXT_color_buffer_float') ? 'Yes' : 'No'}`);
                log('init-output', `Programs compiled: ${Object.keys(context.programs).length}`);
            } catch (error) {
                log('init-output', `Error: ${error.message}`, 'error');
                console.error(error);
            }
        };

        window.createNetworkTest = function() {
            const output = document.getElementById('network-output');
            output.innerHTML = '';

            if (!context) {
                log('network-output', 'Please initialize graphics context first!', 'error');
                return;
            }

            try {
                const layerSpecs = [
                    createLayerSpecification(2, 8, 'tanh'),
                    createLayerSpecification(8, 1, 'sigmoid')
                ];

                network = initializeNetwork(context, layerSpecs);

                log('network-output', 'Network created successfully!', 'success');
                log('network-output', 'Architecture: 2 → 8 → 1');
                log('network-output', `Total layers: ${network.layers.length}`);

                network.layers.forEach((layer, i) => {
                    log('network-output',
                        `Layer ${i}: ${layer.inputDimension} → ${layer.outputDimension} (${layer.activationFunction})`);
                });
            } catch (error) {
                log('network-output', `Error: ${error.message}`, 'error');
                console.error(error);
            }
        };

        window.forwardTest = function() {
            const output = document.getElementById('forward-output');
            output.innerHTML = '';

            if (!network) {
                log('forward-output', 'Please create a network first!', 'error');
                return;
            }

            try {
                const testInputs = [
                    [0, 0],
                    [0, 1],
                    [1, 0],
                    [1, 1]
                ];

                log('forward-output', 'Testing forward propagation with XOR inputs:', 'success');

                testInputs.forEach((input) => {
                    const result = computeNetworkForward(context, network, input);
                    log('forward-output', `Input [${input.join(', ')}] → Output: ${result[0].toFixed(6)}`);
                });

                log('forward-output', '\nNote: Outputs are random since network is untrained');
            } catch (error) {
                log('forward-output', `Error: ${error.message}`, 'error');
                console.error(error);
            }
        };

        window.trainingTest = function() {
            const output = document.getElementById('training-output');
            output.innerHTML = '';

            if (!network) {
                log('training-output', 'Please create a network first!', 'error');
                return;
            }

            try {
                log('training-output', 'Training network on XOR problem...', 'success');

                const trainingData = [
                    { input: [0, 0], target: [0] },
                    { input: [0, 1], target: [1] },
                    { input: [1, 0], target: [1] },
                    { input: [1, 1], target: [0] }
                ];

                log('training-output', 'Initial outputs (before training):');
                trainingData.forEach((data) => {
                    const result = computeNetworkForward(context, network, data.input);
                    log('training-output',
                        `[${data.input.join(', ')}] → ${result[0].toFixed(4)} (target: ${data.target[0]})`);
                });

                const epochs = 5000;
                const learningRate = 0.01;

                log('training-output', `\nTraining for ${epochs} epochs with learning rate ${learningRate}...`);
                log('training-output', 'Updating every 100 epochs...\n');

                // Use setTimeout to allow UI updates between epochs
                let epoch = 0;

                function trainEpoch() {
                    let totalLoss = 0;

                    for (const data of trainingData) {
                        const loss = trainNetworkSingleStep(
                            context,
                            network,
                            data.input,
                            data.target,
                            learningRate
                        );
                        totalLoss += loss;
                    }

                    const averageLoss = totalLoss / trainingData.length;

                    if (epoch % 100 === 0 || epoch === epochs - 1) {
                        log('training-output', `Epoch ${epoch}: Average Loss = ${averageLoss.toFixed(6)}`);
                    }

                    if (averageLoss < 0.001) {
                        log('training-output', `Converged at epoch ${epoch}!`, 'success');
                        showResults();
                        return;
                    }

                    epoch++;

                    if (epoch < epochs) {
                        // Continue training
                        setTimeout(trainEpoch, 0);
                    } else {
                        // Training complete
                        showResults();
                    }
                }

                function showResults() {
                    log('training-output', '\nFinal outputs (after training):');
                    trainingData.forEach((data) => {
                        const result = computeNetworkForward(context, network, data.input);
                        const error = Math.abs(result[0] - data.target[0]);
                        const correct = error < 0.1 ? '✓' : '✗';
                        log('training-output',
                            `[${data.input.join(', ')}] → ${result[0].toFixed(4)} (target: ${data.target[0]}) ${correct}`);
                    });

                    log('training-output', '\n🎉 Training complete!', 'success');
                    log('training-output', 'Network learned XOR function using GPU-accelerated backpropagation');
                }

                // Start training
                trainEpoch();

            } catch (error) {
                log('training-output', `Error: ${error.message}`, 'error');
                console.error(error);
            }
        };

        window.performanceTest = function() {
            const output = document.getElementById('performance-output');
            output.innerHTML = '';

            if (!network) {
                log('performance-output', 'Please create a network first!', 'error');
                return;
            }

            try {
                log('performance-output', 'Running performance test...', 'success');

                const iterations = 1000;
                const testInput = [0.5, 0.7];

                log('performance-output', `Testing with ${iterations} iterations...`);

                const startTime = performance.now();
                for (let i = 0; i < iterations; i++) {
                    computeNetworkForward(context, network, testInput);
                }
                const endTime = performance.now();

                const totalTime = endTime - startTime;
                const averageTime = totalTime / iterations;

                log('performance-output', `Total time: ${totalTime.toFixed(2)}ms`);
                log('performance-output', `Average time per forward pass: ${averageTime.toFixed(4)}ms`);
                log('performance-output', `Throughput: ${(1000 / averageTime).toFixed(0)} forward passes/second`);

                const sampleOutput = computeNetworkForward(context, network, testInput);
                log('performance-output', `Sample output: [${sampleOutput.map(v => v.toFixed(6)).join(', ')}]`);

                log('performance-output', '\n✓ Performance test complete', 'success');

            } catch (error) {
                log('performance-output', `Error: ${error.message}`, 'error');
                console.error(error);
            }
        };

        window.onload = function() {
            const output = document.getElementById('init-output');
            output.innerHTML = '';
            log('init-output', 'Page loaded. Click "Initialize Graphics Context" to start.');
        };

        window.debugGradients = function() {
            const output = document.getElementById('debug-output');
            output.innerHTML = '';

            if (!network) {
                log('debug-output', 'Please create a network first!', 'error');
                return;
            }

            try {
                log('debug-output', 'Checking GPU weight updates...', 'success');

                const gl = context.gl;
                const layer0 = network.resources[0];

                // Read a few weights from GPU before training
                gl.bindFramebuffer(gl.FRAMEBUFFER, layer0.framebuffers.weightsPrimary);
                const beforeWeights = new Float32Array(4 * 4); // Read 4 pixels (16 floats)
                gl.readPixels(0, 0, 2, 2, gl.RGBA, gl.FLOAT, beforeWeights);

                log('debug-output', 'Before training - First 4 weight values:');
                log('debug-output', `  ${beforeWeights[0].toFixed(6)}, ${beforeWeights[4].toFixed(6)}, ${beforeWeights[8].toFixed(6)}, ${beforeWeights[12].toFixed(6)}`);

                // Do one training step
                const input = [0, 1];
                const target = [1];
                const lr = 0.1;

                const lossBefore = trainNetworkSingleStep(context, network, input, target, lr);

                // Read weights from GPU after training
                // Need to check which buffer is active now
                const activeWeights = layer0.weightsActive;
                const activeFB = (activeWeights === layer0.weightsPrimary)
                    ? layer0.framebuffers.weightsPrimary
                    : layer0.framebuffers.weightsSecondary;

                gl.bindFramebuffer(gl.FRAMEBUFFER, activeFB);
                const afterWeights = new Float32Array(4 * 4);
                gl.readPixels(0, 0, 2, 2, gl.RGBA, gl.FLOAT, afterWeights);

                log('debug-output', '\nAfter training - First 4 weight values:');
                log('debug-output', `  ${afterWeights[0].toFixed(6)}, ${afterWeights[4].toFixed(6)}, ${afterWeights[8].toFixed(6)}, ${afterWeights[12].toFixed(6)}`);

                log('debug-output', `\nLoss: ${lossBefore.toFixed(6)}`);

                // Check if any weights changed
                let changed = false;
                let maxChange = 0;
                for (let i = 0; i < 16; i++) {
                    const change = Math.abs(afterWeights[i] - beforeWeights[i]);
                    maxChange = Math.max(maxChange, change);
                    if (change > 0.000001) changed = true;
                }

                log('debug-output', `\nWeights changed on GPU: ${changed ? 'YES' : 'NO'}`);
                log('debug-output', `Max change: ${maxChange.toFixed(8)}`);

                if (!changed) {
                    log('debug-output', 'ERROR: GPU weights are NOT changing!', 'error');
                } else {
                    log('debug-output', 'GPU weights are changing ✓', 'success');
                }

            } catch (error) {
                log('debug-output', `Error: ${error.message}`, 'error');
                console.error(error);
            }
        };
    </script>
</body>
</html>