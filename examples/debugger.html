<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neural Network Debugger</title>
    <style>
        :root {
            --font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            --primary-color: #58a6ff;
            --primary-hover-color: #71b0f8;
            --error-color: #f85149;
            --success-color: #238636;
            --success-hover-color: #2ea043;
            --success-text-color: #ffffff;
            --danger-color: #da3633;
            --danger-hover-color: #f85149;
            --danger-text-color: #ffffff;
            --warning-color: #d29922;
            --log-success-color: #3fb950;
            --background-primary: #0d1117;
            --background-secondary: #161b22;
            --background-tertiary: #21262d;
            --background-hover: #30363d;
            --text-color: #c9d1d9;
            --text-muted: #8b949e;
            --border-color: #30363d;
            --border-subtle: #21262d;
            --neuron-inactive: #161b22;
            --neuron-active: #21262d;
            --neuron-stroke-inactive: #30363d;
            --neuron-stroke-active: #484f58;
            --neuron-activation-color: #ffffff;
            --connection-color: #30363d;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family);
            background: var(--background-primary);
            color: var(--text-color);
            min-width: 1600px;
            min-height: 900px;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 400px 1fr 350px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            max-height: 100vh;
            overflow: hidden;
        }

        .header {
            grid-column: 1 / -1;
            background: var(--background-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
        }

        .header h1 {
            font-size: 18px;
            font-weight: 600;
            color: var(--primary-color);
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .playback-controls {
            display: flex;
            gap: 8px;
        }

        .control-btn {
            width: 36px;
            height: 36px;
            background: var(--background-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
        }

        .control-btn:hover:not(:disabled) {
            background: var(--background-hover);
            border-color: var(--primary-color);
        }

        .control-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .control-btn.active {
            background: var(--primary-color);
            border-color: var(--primary-color);
        }

        .control-btn svg {
            width: 24px;
            height: 24px;
            flex-shrink: 0;
            fill: var(--text-color);
        }

        .control-btn.active svg {
            fill: white;
        }

        .tooltip {
            position: absolute;
            top: -35px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--background-tertiary);
            border: 1px solid var(--border-color);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.15s ease;
            z-index: 1000;
        }

        .control-btn:hover .tooltip {
            opacity: 1;
        }

        .step-indicator {
            font-size: 12px;
            color: var(--text-muted);
            padding: 4px 8px;
            background: var(--background-tertiary);
            border-radius: 4px;
            border: 1px solid var(--border-subtle);
        }

        .controls {
            background: var(--background-primary);
            border-right: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
        }

        .control-section {
            margin-bottom: 24px;
        }

        .control-section h3 {
            color: var(--text-muted);
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .layer-info {
            background: var(--background-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .layer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .layer-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--primary-color);
        }

        .layer-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 500;
        }

        .layer-status.idle {
            background: var(--background-tertiary);
            color: var(--text-muted);
        }

        .layer-status.computing {
            background: var(--warning-color);
            color: var(--neuron-activation-color);
        }

        .layer-status.complete {
            background: var(--success-color);
            color: var(--neuron-activation-color);
        }

        .layer-details {
            font-size: 11px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .texture-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 11px;
        }

        .texture-item {
            background: var(--background-tertiary);
            border: 1px solid var(--border-subtle);
            border-radius: 4px;
            padding: 6px;
        }

        .texture-label {
            color: var(--text-muted);
            margin-bottom: 2px;
        }

        .texture-value {
            color: var(--text-color);
            font-weight: 500;
        }

        textarea, input[type="text"], input[type="number"] {
            width: 100%;
            background: var(--background-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 8px 12px;
            font-family: var(--font-family);
            font-size: 12px;
            border-radius: 6px;
            resize: vertical;
        }

        textarea:focus, input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        textarea.invalid, input.invalid {
            border-color: var(--error-color);
        }

        .input-label {
            display: block;
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 6px;
            font-weight: 500;
        }

        .input-group {
            margin-bottom: 16px;
        }

        button {
            width: 100%;
            background: var(--background-secondary);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 500;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 8px;
            transition: all 0.15s ease;
            font-family: inherit;
        }

        button:hover:not(:disabled) {
            background: var(--background-hover);
            border-color: var(--text-muted);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.success {
            background: var(--success-color);
            border-color: var(--success-color);
            color: var(--success-text-color);
        }

        button.success:hover:not(:disabled) {
            background: var(--success-hover-color);
        }

        button.danger {
            background: var(--danger-color);
            border-color: var(--danger-color);
            color: var(--danger-text-color);
        }

        button.danger:hover:not(:disabled) {
            background: var(--danger-hover-color);
        }

        .visualization {
            background: var(--background-primary);
            padding: 24px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
        }

        .network-canvas {
            flex: 1;
            background: var(--background-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .sidebar {
            background: var(--background-primary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0;
        }

        .metrics {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-subtle);
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        .metric-label {
            font-size: 12px;
            color: var(--text-muted);
        }

        .metric-value {
            font-size: 14px;
            font-weight: 600;
            color: var(--primary-color);
        }

        .logs {
            flex: 1;
            padding: 20px;
            background: var(--background-secondary);
            overflow-y: auto;
            font-family: var(--font-family);
            font-size: 11px;
            line-height: 1.4;
            min-height: 0;
        }

        .log-entry {
            padding: 4px 0;
            margin-bottom: 2px;
            border-radius: 3px;
        }

        .log-entry.info {
            color: var(--text-color);
        }

        .log-entry.success {
            color: var(--log-success-color);
        }

        .log-entry.warning {
            color: var(--warning-color);
        }

        .log-entry.error {
            color: var(--error-color);
        }

        .log-time {
            color: var(--text-muted);
            margin-right: 8px;
        }
    </style>
    <script src="../dist/neural-network.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Neural Network Debugger</h1>
        </div>

        <div class="controls">
            <div class="control-section">
                <h3>Network Configuration</h3>
                <div class="input-group">
                    <label class="input-label">Network Layers JSON</label>
                    <textarea id="network-config" rows="6" placeholder='[{"in": 2, "out": 3, "activation": "sigmoid"}, {"in": 3, "out": 1, "activation": "sigmoid"}]'>[{"in": 2, "out": 3, "activation": "sigmoid"}, {"in": 3, "out": 1, "activation": "sigmoid"}]</textarea>
                </div>
                <button onclick="initializeContext()" id="init-btn">Initialize WebGL</button>
                <button onclick="createNetwork()" id="create-btn" disabled>Create Network</button>
            </div>

            <div class="control-section">
                <h3>Playback Controls</h3>
                <div class="playback-controls">
                    <button class="control-btn" id="play-btn" onclick="togglePlayback()">
                        <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g class="play-circle-outline"><g fill="currentColor" fill-rule="evenodd" class="Vector" clip-rule="evenodd"><path d="M22 12c0 5.523-4.477 10-10 10S2 17.523 2 12S6.477 2 12 2s10 4.477 10 10m-10 8a8 8 0 1 0 0-16a8 8 0 0 0 0 16"/><path d="M8 14.091v-4.22c0-1.874 1.954-3.108 3.646-2.302l4.22 2.01c1.898.903 1.949 3.585.087 4.56l-4.22 2.21C10.035 17.24 8 16.009 8 14.092Zm2.805.487a.55.55 0 0 1-.805-.487v-4.22a.55.55 0 0 1 .787-.496l4.22 2.009a.55.55 0 0 1 .018.984z"/></g></g></svg>
                        <div class="tooltip">Play/Pause</div>
                    </button>
                    <button class="control-btn" id="step-btn" onclick="stepForward()">
                        <svg id="step-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g class="arrow-right-circle-outline"><g fill="currentColor" fill-rule="evenodd" class="Vector" clip-rule="evenodd"><path d="M22 12c0 5.523-4.477 10-10 10S2 17.523 2 12S6.477 2 12 2s10 4.477 10 10m-10 8a8 8 0 1 0 0-16a8 8 0 0 0 0 16"/><path d="M17 12a1 1 0 0 1-1 1H8a1 1 0 1 1 0-2h8a1 1 0 0 1 1 1"/><path d="M16.707 11.293a1 1 0 0 1 0 1.414l-3 3a1 1 0 0 1-1.414-1.414L14.586 12l-2.293-2.293a1 1 0 0 1 1.414-1.414z"/></g></g></svg>
                        <div class="tooltip">Step Forward</div>
                    </button>
                    <button class="control-btn" id="stop-btn" onclick="stopExecution()" disabled>
                        <svg id="stop-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g class="stop-circle-outline"><g fill="currentColor" fill-rule="evenodd" class="Vector" clip-rule="evenodd"><path d="M22 12c0 5.523-4.477 10-10 10S2 17.523 2 12S6.477 2 12 2s10 4.477 10 10m-10 8a8 8 0 1 0 0-16a8 8 0 0 0 0 16"/><path d="M10 7.5h4a2.5 2.5 0 0 1 2.5 2.5v4a2.5 2.5 0 0 1-2.5 2.5h-4A2.5 2.5 0 0 1 7.5 14v-4A2.5 2.5 0 0 1 10 7.5m0 2a.5.5 0 0 0-.5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 0-.5-.5z"/></g></g></svg>
                        <div class="tooltip">Stop</div>
                    </button>
                    <button class="control-btn" id="reset-btn" onclick="resetNetwork()">
                        <svg id="reset-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g class="rotate-left-outline"><g fill="currentColor" fill-rule="evenodd" class="Vector" clip-rule="evenodd"><path d="M12 6.05c3.869 0 7 3.126 7 6.975C19 16.875 15.869 20 12 20s-7-3.126-7-6.975c0-1.07.242-2.083.673-2.987a1 1 0 0 0-1.806-.86A8.9 8.9 0 0 0 3 13.024C3 17.985 7.032 22 12 22s9-4.015 9-8.975s-4.032-8.974-9-8.974c-1.24 0-2.425.25-3.502.705l.777 1.843A7 7 0 0 1 12 6.05"/><path d="M10.194 2.233a.857.857 0 0 0-1.15.385L7.713 5.301a1.086 1.086 0 0 0 .493 1.456l2.691 1.329a.857.857 0 1 0 .758-1.536L9.53 5.5l1.053-2.118a.857.857 0 0 0-.388-1.149Z"/></g></g></svg>
                        <div class="tooltip">Reset</div>
                    </button>
                </div>
                <div class="step-indicator" id="step-indicator">Ready</div>
            </div>

            <div class="control-section">
                <h3>Training Data</h3>
                <div class="input-group">
                    <label class="input-label">Input Values</label>
                    <textarea id="input-values" rows="2" placeholder="[0.5, 0.8]">[0.5, 0.8]</textarea>
                </div>
                <div class="input-group">
                    <label class="input-label">Target Values</label>
                    <textarea id="target-values" rows="2" placeholder="[0.7]">[0.7]</textarea>
                </div>
                <div class="input-group">
                    <label class="input-label">Learning Rate</label>
                    <input type="number" id="learning-rate" value="0.1" step="0.01" min="0.001" max="1.0">
                </div>
            </div>

            <div class="control-section">
                <h3>Layer Information</h3>
                <div id="layer-info-container">
                    <!-- Layer information will be populated here -->
                </div>
            </div>
        </div>

        <div class="visualization">
            <canvas class="network-canvas" id="network-canvas"></canvas>
        </div>

        <div class="sidebar">
            <div class="metrics">
                <h3 style="margin-bottom: 16px; color: var(--text-muted); font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">METRICS</h3>
                <div class="metric-row">
                    <span class="metric-label">Output</span>
                    <span class="metric-value" id="metric-output">—</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Target</span>
                    <span class="metric-value" id="metric-target">—</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Error</span>
                    <span class="metric-value" id="metric-error">—</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Loss</span>
                    <span class="metric-value" id="metric-loss">—</span>
                </div>
                <div class="metric-row">
                    <span class="metric-label">Step</span>
                    <span class="metric-value" id="metric-step">0</span>
                </div>
            </div>
            <div class="logs" id="logs"></div>
        </div>
    </div>

    <script type="module">
        const { 
            initializeGraphicsContext, 
            initializeNetwork, 
            createLayerSpecification, 
            createNetworkState,
            addLayerToNetwork,
            computeNetworkForward,
            trainNetworkSingleStep
        } = NeuralNetwork;

        let context = null;
        let network = null;
        let networkViz = null;
        let currentStep = 0;
        let isPlaying = false;
        let currentLayerStep = 0;
        let playbackInterval = null;
        let currentPhase = 'idle'; // 'idle', 'forward', 'backward'

        function log(message, type = 'info') {
            const logs = document.getElementById('logs');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            
            const time = new Date().toLocaleTimeString();
            entry.innerHTML = `<span class="log-time">${time}</span>${message}`;
            
            logs.appendChild(entry);
            logs.scrollTop = logs.scrollHeight;
        }

        function validateJSON(elementId, label) {
            const element = document.getElementById(elementId);
            try {
                const value = JSON.parse(element.value);
                element.classList.remove('invalid');
                return value;
            } catch (e) {
                element.classList.add('invalid');
                log(`Invalid ${label}: ${e.message}`, 'error');
                return null;
            }
        }

        function updateStepIndicator(text) {
            document.getElementById('step-indicator').textContent = text;
            document.getElementById('metric-step').textContent = currentStep;
        }

        function updateLayerInfo() {
            const container = document.getElementById('layer-info-container');
            container.innerHTML = '';

            if (!network || !network.layers) return;

            network.layers.forEach((layer, index) => {
                const layerDiv = document.createElement('div');
                layerDiv.className = 'layer-info';
                
                let status = 'idle';
                if (currentPhase === 'forward' && currentLayerStep === index) {
                    status = 'computing';
                } else if (currentPhase === 'forward' && currentLayerStep > index) {
                    status = 'complete';
                } else if (currentPhase === 'backward') {
                    status = 'complete';
                }

                layerDiv.innerHTML = `
                    <div class="layer-header">
                        <div class="layer-title">Layer ${index + 1}</div>
                        <div class="layer-status ${status}">${status.toUpperCase()}</div>
                    </div>
                    <div class="layer-details">
                        ${layer.inputDimension} → ${layer.outputDimension} (${layer.activationFunction})
                    </div>
                    <div class="texture-grid">
                        <div class="texture-item">
                            <div class="texture-label">Weights</div>
                            <div class="texture-value">${layer.inputDimension}×${layer.outputDimension}</div>
                        </div>
                        <div class="texture-item">
                            <div class="texture-label">Biases</div>
                            <div class="texture-value">${layer.outputDimension}×1</div>
                        </div>
                        <div class="texture-item">
                            <div class="texture-label">Outputs</div>
                            <div class="texture-value">${layer.outputDimension}×1</div>
                        </div>
                        <div class="texture-item">
                            <div class="texture-label">Gradients</div>
                            <div class="texture-value">${status === 'complete' ? 'Computed' : 'Pending'}</div>
                        </div>
                    </div>
                `;
                
                container.appendChild(layerDiv);
            });
        }

        function updateButtons() {
            const playBtn = document.getElementById('play-btn');
            const stepBtn = document.getElementById('step-btn');
            const stopBtn = document.getElementById('stop-btn');
            const resetBtn = document.getElementById('reset-btn');
            const initBtn = document.getElementById('init-btn');
            const createBtn = document.getElementById('create-btn');

            // Update control button states
            createBtn.disabled = !context;
            stepBtn.disabled = !network || isPlaying;
            stopBtn.disabled = !isPlaying;
            playBtn.disabled = !network;
            resetBtn.disabled = !network;

            // Update play/stop icon
            const playIcon = document.getElementById('play-icon');
            const stopIcon = document.getElementById('stop-icon');
            if (isPlaying) {
                playIcon.style.display = 'none';
                stopIcon.style.display = 'block';
                playBtn.classList.add('active');
            } else {
                playIcon.style.display = 'block';
                stopIcon.style.display = 'none';
                playBtn.classList.remove('active');
            }
        }

        function initNetworkVisualization() {
            if (!network) return;
            
            const canvas = document.getElementById('network-canvas');
            const ctx = canvas.getContext('2d');
            
            // Get the actual container size
            const container = canvas.parentElement;
            const containerRect = container.getBoundingClientRect();
            const availableWidth = containerRect.width - 48; // Account for padding
            const availableHeight = containerRect.height - 48; // Account for padding
            
            // Set canvas size to fit container
            canvas.width = availableWidth * devicePixelRatio;
            canvas.height = availableHeight * devicePixelRatio;
            canvas.style.width = availableWidth + 'px';
            canvas.style.height = availableHeight + 'px';
            ctx.scale(devicePixelRatio, devicePixelRatio);

            networkViz = {
                canvas,
                ctx,
                currentValues: new Array(network.layers.length + 1).fill(null),
                layerPositions: []
            };

            // Calculate layer positions
            const layers = [network.inputDimension, ...network.layers.map(l => l.outputDimension)];
            const canvasWidth = availableWidth;
            const canvasHeight = availableHeight;
            const margin = 80;
            const layerSpacing = (canvasWidth - 2 * margin) / (layers.length - 1);

            layers.forEach((size, layerIdx) => {
                const neurons = [];
                const neuronSpacing = Math.min(40, (canvasHeight - 2 * margin) / Math.max(1, size - 1));
                const startY = (canvasHeight - (size - 1) * neuronSpacing) / 2;

                for (let i = 0; i < size; i++) {
                    neurons.push({
                        x: margin + layerIdx * layerSpacing,
                        y: startY + i * neuronSpacing
                    });
                }
                networkViz.layerPositions.push(neurons);
            });

            drawNetwork();
        }

        function drawNetwork(activeLayer = -1) {
            if (!networkViz) return;

            const { ctx, layerPositions, currentValues } = networkViz;
            const canvas = networkViz.canvas;
            
            // Get actual canvas display size
            const canvasWidth = parseFloat(canvas.style.width) || canvas.width / devicePixelRatio;
            const canvasHeight = parseFloat(canvas.style.height) || canvas.height / devicePixelRatio;
            
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);

            // Draw connections
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--connection-color').trim();
            ctx.lineWidth = 1;
            
            for (let i = 0; i < layerPositions.length - 1; i++) {
                const currentLayer = layerPositions[i];
                const nextLayer = layerPositions[i + 1];
                
                currentLayer.forEach(neuron1 => {
                    nextLayer.forEach(neuron2 => {
                        ctx.beginPath();
                        ctx.moveTo(neuron1.x, neuron1.y);
                        ctx.lineTo(neuron2.x, neuron2.y);
                        ctx.stroke();
                    });
                });
            }

            // Draw neurons
            const neuronRadius = 20;
            layerPositions.forEach((layer, layerIdx) => {
                layer.forEach((neuron, neuronIdx) => {
                    const values = currentValues[layerIdx];
                    const value = values ? values[neuronIdx] || 0 : 0;
                    const isActive = layerIdx === activeLayer;

                    let fillColor, strokeColor;
                    if (isActive) {
                        fillColor = getComputedStyle(document.documentElement).getPropertyValue('--neuron-active').trim();
                        strokeColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
                    } else {
                        fillColor = getComputedStyle(document.documentElement).getPropertyValue('--neuron-inactive').trim();
                        strokeColor = getComputedStyle(document.documentElement).getPropertyValue('--neuron-stroke-inactive').trim();
                    }

                    ctx.fillStyle = fillColor;
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(neuron.x, neuron.y, neuronRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw value
                    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
                    ctx.font = '11px Monaco';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(value.toFixed(2), neuron.x, neuron.y);
                });
            });

            // Draw layer labels
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-muted').trim();
            ctx.font = '12px Monaco';
            ctx.textAlign = 'center';
            layerPositions.forEach((layer, idx) => {
                const label = idx === 0 ? 'Input' : idx === layerPositions.length - 1 ? 'Output' : `Hidden ${idx}`;
                ctx.fillText(label, layer[0].x, 20);
            });
        }

        function updateNetworkVisualization(layerIdx, values) {
            if (!networkViz) return;
            networkViz.currentValues[layerIdx] = values;
            drawNetwork(layerIdx);
            updateLayerInfo();
        }

        window.initializeContext = function() {
            log('Initializing WebGL2...', 'info');
            try {
                context = initializeGraphicsContext();
                log('WebGL2 initialized successfully', 'success');
                currentStep = 1;
                updateButtons();
                updateStepIndicator('WebGL Initialized');
            } catch (e) {
                log(`Error initializing WebGL: ${e.message}`, 'error');
            }
        };

        window.createNetwork = function() {
            const config = validateJSON('network-config', 'Network Configuration');
            if (!config) return;

            log('Creating neural network...', 'info');
            try {
                const layerSpecs = config.map(s => createLayerSpecification(s.in, s.out, s.activation));
                network = initializeNetwork(context, layerSpecs);
                network.inputDimension = config[0].in;

                log('Network created successfully', 'success');
                config.forEach((s, i) => log(`Layer ${i + 1}: ${s.in}→${s.out} (${s.activation})`, 'info'));

                initNetworkVisualization();
                currentStep = 2;
                currentLayerStep = 0;
                currentPhase = 'idle';
                updateButtons();
                updateLayerInfo();
                updateStepIndicator('Network Ready');
            } catch (e) {
                log(`Error creating network: ${e.message}`, 'error');
            }
        };

        window.togglePlayback = function() {
            if (!network) return;

            if (isPlaying) {
                // Pause
                isPlaying = false;
                if (playbackInterval) {
                    clearInterval(playbackInterval);
                    playbackInterval = null;
                }
                log('Playback paused', 'warning');
            } else {
                // Play
                isPlaying = true;
                log('Starting automatic playback...', 'info');
                playbackInterval = setInterval(() => {
                    stepForward();
                }, 800);
            }
            
            updateButtons();
            updateStepIndicator(isPlaying ? 'Playing' : 'Paused');
        };

        window.stepForward = function() {
            if (!network || isPlaying && !playbackInterval) return;

            const inputValues = validateJSON('input-values', 'Input Values');
            const targetValues = validateJSON('target-values', 'Target Values');
            if (!inputValues || !targetValues) return;

            if (currentPhase === 'idle' || (currentPhase === 'backward' && currentLayerStep >= network.layers.length)) {
                // Start forward pass
                currentPhase = 'forward';
                currentLayerStep = 0;
                log('=== Starting Forward Pass ===', 'info');
                
                // Upload input
                log(`Input: [${inputValues.join(', ')}]`, 'info');
                updateNetworkVisualization(0, inputValues);
                updateStepIndicator('Processing Input');
            }

            if (currentPhase === 'forward') {
                if (currentLayerStep < network.layers.length) {
                    // Process current layer
                    log(`Processing Layer ${currentLayerStep + 1}...`, 'info');
                    
                    try {
                        // Simplified forward pass for this layer
                        const output = computeNetworkForward(context, network, inputValues);
                        const layer = network.layers[currentLayerStep];
                        
                        // Update visualization (this is simplified - in real implementation you'd get layer-specific outputs)
                        if (currentLayerStep === network.layers.length - 1) {
                            updateNetworkVisualization(currentLayerStep + 1, output);
                            
                            // Calculate metrics
                            const error = Math.abs(output[0] - targetValues[0]);
                            const loss = error * error;
                            
                            document.getElementById('metric-output').textContent = output[0].toFixed(4);
                            document.getElementById('metric-target').textContent = targetValues[0].toFixed(4);
                            document.getElementById('metric-error').textContent = error.toFixed(4);
                            document.getElementById('metric-loss').textContent = loss.toFixed(6);
                            
                            log(`Output: ${output[0].toFixed(4)}, Target: ${targetValues[0].toFixed(4)}, Error: ${error.toFixed(4)}`, 
                                error < 0.1 ? 'success' : 'warning');
                        }
                        
                        currentLayerStep++;
                        updateLayerInfo();
                        
                        if (currentLayerStep >= network.layers.length) {
                            currentPhase = 'backward';
                            currentLayerStep = network.layers.length - 1;
                            log('=== Starting Backward Pass ===', 'info');
                            updateStepIndicator('Forward Complete - Starting Backprop');
                        } else {
                            updateStepIndicator(`Layer ${currentLayerStep} Complete`);
                        }
                        
                    } catch (e) {
                        log(`Error in forward pass: ${e.message}`, 'error');
                        if (isPlaying) {
                            window.stopExecution();
                        }
                    }
                }
            } else if (currentPhase === 'backward') {
                if (currentLayerStep >= 0) {
                    // Process backward pass for current layer
                    log(`Backpropagating Layer ${currentLayerStep + 1}...`, 'info');
                    
                    try {
                        // Simplified backward pass
                        const learningRate = parseFloat(document.getElementById('learning-rate').value) || 0.1;
                        trainNetworkSingleStep(context, network, inputValues, targetValues, learningRate);
                        
                        currentLayerStep--;
                        updateLayerInfo();
                        
                        if (currentLayerStep < 0) {
                            currentPhase = 'idle';
                            currentLayerStep = 0;
                            currentStep++;
                            log('=== Training Step Complete ===', 'success');
                            updateStepIndicator(`Step ${currentStep} Complete`);
                        } else {
                            updateStepIndicator(`Backprop Layer ${currentLayerStep + 1}`);
                        }
                        
                    } catch (e) {
                        log(`Error in backward pass: ${e.message}`, 'error');
                        if (isPlaying) {
                            window.stopExecution();
                        }
                    }
                }
            }

            updateButtons();
        };

        window.stopExecution = function() {
            isPlaying = false;
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
            }
            log('Execution stopped', 'warning');
            updateButtons();
            updateStepIndicator('Stopped');
        };

        window.resetNetwork = function() {
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
            }
            
            isPlaying = false;
            currentStep = 2;
            currentLayerStep = 0;
            currentPhase = 'idle';
            
            // Reset metrics
            document.getElementById('metric-output').textContent = '—';
            document.getElementById('metric-target').textContent = '—';
            document.getElementById('metric-error').textContent = '—';
            document.getElementById('metric-loss').textContent = '—';
            
            if (networkViz) {
                networkViz.currentValues.fill(null);
                drawNetwork();
            }
            
            log('Network reset', 'warning');
            updateButtons();
            updateLayerInfo();
            updateStepIndicator('Reset');
        };

        window.onload = function() {
            log('Neural Network Debugger loaded', 'info');
            updateButtons();
        };
    </script>
</body>
</html>